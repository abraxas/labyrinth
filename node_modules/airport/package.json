{
  "name": "airport",
  "description": "role-based port management for upnode",
  "version": "0.4.3",
  "repository": {
    "type": "git",
    "url": "git://github.com/substack/airport.git"
  },
  "main": "index.js",
  "keywords": [
    "upnode",
    "dnode",
    "seaport",
    "port"
  ],
  "directories": {
    "lib": ".",
    "example": "example",
    "test": "test"
  },
  "scripts": {
    "test": "tap test/*.js"
  },
  "dependencies": {
    "upnode": "~0.4.1",
    "deck": "~0.0.4",
    "seaport": "~0.8.0"
  },
  "devDependencies": {
    "tap": "~0.3.0"
  },
  "engines": {
    "node": ">=0.6.0"
  },
  "license": "MIT",
  "author": {
    "name": "James Halliday",
    "email": "mail@substack.net",
    "url": "http://substack.net"
  },
  "readme": "airport\n=======\n\nProvide an\n[upnode](https://github.com/substack/upnode)-style\n[dnode](https://github.com/substack/dnode) connection using service names from a\n[seaport](https://github.com/substack/seaport) server.\n\nInstead of connecting and listening on hosts and ports, you can .connect() and\n.listen() on service semvers.\n\n[![build status](https://secure.travis-ci.org/substack/airport.png)](http://travis-ci.org/substack/airport)\n\n![airport](http://substack.net/images/airport.png)\n\nexample\n=======\n\nbeep.js\n\n``` js\nvar airport = require('airport');\nvar air = airport('localhost', 9090);\n\nair(function (remote, conn) {\n    this.fives = function (n, cb) { cb(n * 5) }\n}).listen('beep');\n```\n\nconnect.js\n\n``` js\nvar airport = require('airport');\nvar air = airport('localhost', 9090);\n\nvar up = air.connect('beep');\n\nsetInterval(function () {\n    up(function (remote) {\n        remote.fives(11, function (n) {\n            console.log('fives(11) : ' + n);\n        });\n    });\n}, 1000);\n```\n\nFirst start a seaport server:\n\n```\n$ seaport 9090\nseaport listening on :9090\n```\n\nthen fire up the beep server:\n\n```\n$ node beep.js\n```\n\nand spin up the beep client:\n\n```\n$ node connect.js\nfives(11) : 55\nfives(11) : 55\nfives(11) : 55\nfives(11) : 55\n```\n\nIf you kill the beep server and bring it up again, the connection requests get\nqueued and fire when the beep server comes back up, even though it got assigned\na different port!\n\nmethods\n=======\n\n```\nvar airport = require('airport');\nvar seaport = require('seaport');\nvar ports = seaport.connect(...);\n```\n\nvar air = airport(ports)\n------------------------\n\nReturn a new airport object `air` from a seaport port allocation object `ports`.\n\nvar air = airport(...)\n----------------------\n\nCreate a new seaport `ports` object from the arguments provided and use that as\na shorthand to return `airport(ports)`.\n\nvar up = air(fn).connect(role)\n------------------------------\n\nReturn a new [upnode](https://github.com/substack/upnode) connection to a\nservice that fulfills `role` with the optional upnode function `fn`.\n\nIf no services for `role` are availble right away the request will be queued\nuntil a service for `role` comes online.\n\nWhen the connection drops and reconnection fails, seaport will be queried for a\nnew host/port endpoint.\n\n`air.connect()` works as a shortcut for `air().connect()` just like in upnode.\n\nair(fn).listen(role, opts={})\n-----------------------------\n\nCreate a new upnode service given the dnode constructor function or object `fn`\nfor the given `role`.\n\nIf you specify a secret phrase in `opts.secret`, that phrase will be put in the\nseaport metadata for your service and clients that `.connect()` will need to\nauthenticate with the secret phrase. This is performed automatically with\n`air.connect()`.\n\nYou can pass metadata directly through `opts.meta`.\n\ninstall\n=======\n\nWith [npm](http://npmjs.org) do:\n\n```\nnpm install airport\n```\n\nlicense\n=======\n\nMIT/X11\n",
  "readmeFilename": "README.markdown",
  "_id": "airport@0.4.3",
  "_from": "airport"
}
